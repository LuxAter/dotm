#!/usr/bin/env bash
# This script was generated by bashly 0.7.9 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n"
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
dotm_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotm - Personal dotfiles manager utility\n"
    echo

  else
    printf "dotm - Personal dotfiles manager utility\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dotm [command]\n"
  printf "  dotm [command] --help | -h\n"
  printf "  dotm --version | -v\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  completions   Generate bash autocompletions"
  echo "  update        Update and install the dotm script"
  printf "\nDotfile Commands:\n"
  echo "  add           Add new files/directories to a dotfile package"
  echo "  install       Copy dotfiles directly into system paths"
  echo "  list          List the state of all the currently configured dotfiles"
  echo "  remove        Remove file from a dotfile package"
  echo "  set           Create links from system files into the dotfiles"
  echo "  unset         Remove links from system files into the dotfiles"
  printf "\nGit Commands:\n"
  echo "  pull          Pull changes from the remote git repo"
  echo "  push          Push local changes to the remote git repo"
  echo "  sync          Sync any changes with the remote git repo"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "Environment Variables:\n"

    # :environment_variable.usage
    echo "  DOTFILES (required)"
    printf "    Path to the local dotfiles repository\n"
    printf "    Default: $HOME/dotfiles.new\n"
    echo

  fi
}

# :command.usage
dotm_completions_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotm completions - Generate bash autocompletions\n"
    echo

  else
    printf "dotm completions - Generate bash autocompletions\n"
    echo

  fi

  printf "Shortcut: C\n"
  echo

  printf "Usage:\n"
  printf "  dotm completions\n"
  printf "  dotm completions --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dotm_update_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotm update - Update and install the dotm script\n"
    echo

  else
    printf "dotm update - Update and install the dotm script\n"
    echo

  fi

  printf "Shortcut: U\n"
  echo

  printf "Usage:\n"
  printf "  dotm update [options]\n"
  printf "  dotm update --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --force, -f"
    printf "    Automatically accept all user prompts\n"
    echo

    # :flag.usage
    echo "  --check, -c"
    printf "    Only check for updates, don't actually update\n"
    echo

    # :flag.usage
    echo "  --no-completion, -C"
    printf "    Don't update the bash completions\n"
    echo

    # :flag.usage
    echo "  --no-dotm, -D"
    printf "    Don't update the dotm script\n"
    echo

    # :flag.usage
    echo "  --url, -U URL"
    printf "    Base url to download the scripts from\n"
    printf "    Default: https://raw.githubusercontent.com/LuxAter/dotm/main\n"
    echo

    # :flag.usage
    echo "  --path, -p PATH"
    printf "    Path of the dotm installation to update\n"
    echo

  fi
}

# :command.usage
dotm_add_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotm add - Add new files/directories to a dotfile package\n"
    echo

  else
    printf "dotm add - Add new files/directories to a dotfile package\n"
    echo

  fi

  printf "Shortcut: a\n"
  echo

  printf "Usage:\n"
  printf "  dotm add FILES... [options]\n"
  printf "  dotm add --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --force, -f"
    printf "    Automatically accept all user prompts\n"
    echo

    # :flag.usage
    echo "  --package, -p PACKAGE"
    printf "    Package to add the new dotfiles into\n"
    printf "    Default: host/$HOSTNAME\n"
    echo

    # :flag.usage
    echo "  --encrypt, -e"
    printf "    Encrypt the dotfile in the repository\n"
    echo

    # :flag.usage
    echo "  --copy, -c"
    printf "    Copy the dotfile instead of using symlinks\n"
    echo

    # :flag.usage
    echo "  --archive, -a"
    printf "    Archive the dotfile in the repository\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  FILES..."
    printf "    List of files or directories to add into the dotfiles\n"
    echo

  fi
}

# :command.usage
dotm_install_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotm install - Copy dotfiles directly into system paths\n"
    echo

  else
    printf "dotm install - Copy dotfiles directly into system paths\n"
    echo

  fi

  printf "Shortcut: i\n"
  echo

  printf "Usage:\n"
  printf "  dotm install [PACKAGES...] [options]\n"
  printf "  dotm install --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --force, -f"
    printf "    Automatically accept all user prompts\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  PACKAGES..."
    printf "    List of dotfile packages to install into the system\n"
    printf "    Default: host/$HOSTNAME\n"
    echo

  fi
}

# :command.usage
dotm_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotm list - List the state of all the currently configured dotfiles\n"
    echo

  else
    printf "dotm list - List the state of all the currently configured dotfiles\n"
    echo

  fi

  printf "Shortcut: l\n"
  echo

  printf "Usage:\n"
  printf "  dotm list [PACKAGES...] [options]\n"
  printf "  dotm list --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --all, -a"
    printf "    Include all dotfiles in the list\n"
    echo

    # :flag.usage
    echo "  --raw, -r"
    printf "    Display a raw list without styling, useful in scripts\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  PACKAGES..."
    printf "    List of dotfile packages to include in the list\n"
    printf "    Default: host/$HOSTNAME\n"
    echo

  fi
}

# :command.usage
dotm_remove_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotm remove - Remove file from a dotfile package\n"
    echo

  else
    printf "dotm remove - Remove file from a dotfile package\n"
    echo

  fi

  printf "Shortcut: r\n"
  echo

  printf "Usage:\n"
  printf "  dotm remove FILES... [options]\n"
  printf "  dotm remove --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --force, -f"
    printf "    Automatically accept all user prompts\n"
    echo

    # :flag.usage
    echo "  --package, -p PACKAGE"
    printf "    Package to remove the dotfiles from\n"
    printf "    Default: host/$HOSTNAME\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  FILES..."
    printf "    List of files or directories to be removed from the dotfiles\n"
    echo

  fi
}

# :command.usage
dotm_set_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotm set - Create links from system files into the dotfiles\n"
    echo

  else
    printf "dotm set - Create links from system files into the dotfiles\n"
    echo

  fi

  printf "Shortcut: s\n"
  echo

  printf "Usage:\n"
  printf "  dotm set [PACKAGES...] [options]\n"
  printf "  dotm set --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --force, -f"
    printf "    Automatically accept all user prompts\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  PACKAGES..."
    printf "    List of dotfile packages to create the links for\n"
    printf "    Default: host/$HOSTNAME\n"
    echo

  fi
}

# :command.usage
dotm_unset_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotm unset - Remove links from system files into the dotfiles\n"
    echo

  else
    printf "dotm unset - Remove links from system files into the dotfiles\n"
    echo

  fi

  printf "Shortcut: u\n"
  echo

  printf "Usage:\n"
  printf "  dotm unset [PACKAGES...] [options]\n"
  printf "  dotm unset --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --force, -f"
    printf "    Automatically accept all user prompts\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  PACKAGES..."
    printf "    List of dotfile packages to remove the links of\n"
    printf "    Default: host/$HOSTNAME\n"
    echo

  fi
}

# :command.usage
dotm_pull_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotm pull - Pull changes from the remote git repo\n"
    echo

  else
    printf "dotm pull - Pull changes from the remote git repo\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dotm pull\n"
  printf "  dotm pull --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dotm_push_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotm push - Push local changes to the remote git repo\n"
    echo

  else
    printf "dotm push - Push local changes to the remote git repo\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dotm push [options]\n"
  printf "  dotm push --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --message, -m MESSAGE"
    printf "    Set the commit message for the local changes\n"
    printf "    Default: $(date +"%Y-%m-%d %H:%M:%S")\n"
    echo

  fi
}

# :command.usage
dotm_sync_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotm sync - Sync any changes with the remote git repo\n"
    echo

  else
    printf "dotm sync - Sync any changes with the remote git repo\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dotm sync [options]\n"
  printf "  dotm sync --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --max-frequnecy, -f DURATION"
    printf "    Set a duration in seconds for how long to wait since the last sync before\n    doing it again\n"
    echo

    # :flag.usage
    echo "  --message, -m MESSAGE"
    printf "    Set the commit message for the local changes\n"
    printf "    Default: $(date +"%Y-%m-%d %H:%M:%S")\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for (( i=0 ; i < ${#flags} ; i++ )); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if (( ${#args[@]} )); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if (( ${#other_args[@]} )); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# src/lib/config.sh
#!/bin/bash

config_get() {
  local file="$1"

  [ -e "$file" ] || return 1

  local found=false
  local body=""
  while IFS= read -r line || [ -n "$line" ]; do
    if [[ "$line" =~ ^\[(.+)\]$ ]]; then
      if [ "${BASH_REMATCH[1]}" == "$2" ]; then
        found=true
      elif [ "$found" == true ]; then
        break
      fi
    elif [ "$found" == true ] && [ -n "$line" ]; then
      body="$body$line\n"
    fi
  done <"$file"

  printf "%b" "$body"
  if [ "$found" == true ]; then return 0; else return 1; fi
}

config_set() {
  local file="$1"
  local key="$2"
  local body="$3"

  [ -d "$(dirname "$file")" ] || mkdir -p "$(dirname "$file")"

  local found=false
  local copy=true
  local output=""
  while IFS= read -r line || [ -n "$line" ]; do
    if [[ "$line" =~ ^\[(.+)\]$ ]]; then
      if [ "${BASH_REMATCH[1]}" == "$key" ]; then
        found=true
        copy=false
        output="${output}[$key]\n$body\n"
      else
        output="$output$line\n"
        copy=true
      fi
    elif [ "$copy" == true ]; then
      output="$output$line\n"
    fi
  done <"$file"

  if [ "$found" == false ]; then
    output="${output}[$key]\n$body"
  fi

  printf "%b" "$output" >"$file"
}

config_del() {
  local file="$1"
  local key="$2"

  local output=""
  local copy=true
  while IFS= read -r line || [ -n "$line" ]; do
    if [[ "$line" =~ ^\[(.+)\]$ ]]; then
      if [ "${BASH_REMATCH[1]}" == "$key" ]; then
        copy=false
      else
        output="$output$line\n"
        copy=true
      fi
    elif [ "$copy" == true ]; then
      output="$output$line\n"
    fi
  done <"$file"

  printf "%b" "$output" >"$file"
}

config_keys() {
  local file="$1"
  local keys=()
  while IFS= read -r line || [ -n "$line" ]; do
    if [[ "$line" =~ ^\[([A-Za-z0-9\/]+)\]$ ]]; then
      keys+=("${BASH_REMATCH[1]}")
    fi
  done <"$file"

  echo -e "${keys[@]}"
}

config_has() {
  [[ " $(config_keys "$1")" = *" $2 "* ]]
}

section_get() {
  local section="$1"
  local key="$2"

  local found=false
  while IFS= read -r line || [ -n "$line" ]; do
    if [[ "$line" =~ ^$key\s*=\s*(.+)\s*$ ]]; then
      found=true
      echo "${BASH_REMATCH[1]}"
      break
    fi
  done < <(echo -e "$section")

  if [ "$found" == true ]; then return 0; else return 1; fi
}

section_set() {
  local section="$1"
  local key="$2"
  local value="$3"

  local found=false
  local output=""
  while IFS= read -r line || [ -n "$line" ]; do
    if [[ "$line" =~ ^$key\s*=\s*.+$ ]]; then
      found=true
      output="$output$key=$value\n"
    elif [ -n "$line" ]; then
      output="$output$line\n"
    fi
  done < <(echo -e "$section")

  if [ "$found" == false ]; then output="$output$key=$value\n"; fi
  printf '%b' "$output"
}

section_del() {
  local section="$1"
  local key="$2"

  local output=""
  while IFS= read -r line || [ -n "$line" ]; do
    if ! [[ "$line" =~ ^$key\s*=\s*.+$ ]] && [ -n "$line" ]; then
      output="$output$line\n"
    fi
  done < <(echo -e "$section")

  printf '%b' "$output"
}

section_keys() {
  local section="$1"
  local keys=()
  while IFS= read -r line || [ -n "$line" ]; do
    if [[ "$line" =~ ^(.*)\s*= ]]; then
      keys+=("${BASH_REMATCH[1]}")
    fi
  done < <(echo -e "$section")

  echo -e "${keys[@]}"
}

section_has() {
  [[ " $(section_keys "$1")" = *" $2 "* ]]
}

config_resolve() {
  local file="$1"
  local key="$2"
  local visited="$3"
  local section="$(config_get "$1" "$2" || true)"
  [ -z "$section" ] && return 0

  if section_has "$section" "depends"; then
    while IFS=' ' read -r dep; do
      echo "HI: $dep"
    done < <(section_get "$section" "depends")
  fi
}

# src/lib/fs.sh
#!/bin/bash

fs_expanduser() {
  echo "${1/"~"/$HOME}"
}

fs_reluser() {
  echo "${1/$HOME/"~"}"
}

fs_reldot() {
  echo "${1/$DOTFILES\//}"
}

fs_dotfile() {
  local rel="$(fs_reluser "$1")"
  local pkg="$2"
  local fname="$(basename "$rel")"
  rel="${rel#"~/"}"
  rel="${rel#"/"}"
  fname="${fname#.}"

  local res=""
  if [ -n "$pkg" ]; then
    res="$DOTFILES/$(dirname "$rel")/$pkg.$fname"
  else
    res="$DOTFILES/$(dirname "$rel")/$fname"
  fi
  echo "${res/\/.\//\/}"
}

fs_hash() {
  if [ -f "$1" ]; then
    openssl md5 "$1" | cut -d' ' -f2
  elif [ -d "$1" ]; then
    find "$1" -type f | sort | xargs cat | openssl md5 | cut -d' ' -f2
  else
    echo "d41d8cd98f00b204e9800998ecf8427e"
  fi
}

fs_archive() {
  local src="$1"
  local dest="$2"
  if ! [ -e "$src" ]; then
    lwarn "File or directory $(lscolor "$src") not found"
    return 1
  fi

  if [ -d "$src" ]; then
    dest="${dest:-${src%/}.tgz}"
    ldebug "Archiving the directory $(lscolor "$src") to $(lscolor "$dest")"

    if ! tar -czf "$dest" -C "$src" "." &>/dev/null; then
      lerror "Failed to create archive of $(lscolor "$src")"
      return 1
    fi
  elif [ -f "$src" ]; then
    dest="${dest:-$src.gz}"
    ldebug "Archiving the file $(lscolor "$src") to $(lscolor "$dest")"

    if ! gzip -9c "$src" 1>"$dest" 2>/dev/null; then
      lerror "Failed to create archive of $(lscolor "$src")"
      return 1
    fi
  else
    lwarn "Cannot archive $(lscolor "$src"), must be a file or directory"
    return 1
  fi
  echo "$dest"
  return 0
}

fs_unarchive() {
  local src="$1"
  local dest="$2"
  if ! [ -e "$src" ]; then
    lwarn "File or directory $(lscolor "$src") not found"
    return 1
  fi

  if [ -f "$src" ]; then
    if [[ "$src" = *.gz ]]; then
      dest="${dest:-${src%.gz}}"
      ldebug "Extracing the file $(lscolor "$src") to $(lscolor "$dest")"

      if ! gzip -cd "$src" 1>"$dest" 2>/dev/null; then
        lerror "Failed to extract archive of $(lscolor "$src")"
        return 1
      fi
    elif [[ "$src" = *.tgz ]]; then
      dest="${dest:-${src%.tgz}}"
      ldebug "Extracing the directory $(lscolor "$src") to $(lscolor "$dest")"

      if ! mkdir -p "$dest"; then
        lerror "Failed to extract archive of $(lscolor "$src")"
        return 1
      elif ! tar -xzf "$src" -C "$dest" &>/dev/null; then
        lerror "Failed to extract archive of $(lscolor "$src")"
        return 1
      fi
    fi
  else
    lwarn "Cannot unarchive $(lscolor "$src"), must be a file"
    return 1
  fi
  echo "$dest"
  return 0
}

fs_encrypt() {
  local pswd="$1"
  local src="$2"
  local dest="$3"

  if ! [ -e "$src" ]; then
    lwarn "File $(lscolor "$src") not found"
    return 1
  fi

  if [ -f "$src" ]; then
    dest="${dest:-$src.enc}"
    ldebug "Encrypting the file $(lscolor "$src") to $(lscolor "$dest")"
    if ! openssl enc -aes-256-cbc -pass "pass:$pswd" -in "$src" -out "$dest" &>/dev/null; then
      lerror "Failed to encrypt $(lscolor "$src")"
      return 1
    fi
  else
    lwarn "Cannot encrypt $(lscolor "$src"), must be a file"
    return 1
  fi
  echo "$dest"
  return 0
}

fs_decrypt() {
  local pswd="$1"
  local src="$2"
  local dest="$3"

  if ! [ -e "$src" ]; then
    lwarn "File $(lscolor "$src") not found"
    return 1
  fi

  if [ -f "$src" ]; then
    dest="${dest:-${src%.enc}}"
    ldebug "Decrypting the file $(lscolor "$src") to $(lscolor "$dest")"
    if ! openssl enc -aes-256-cbc -d -pass "pass:$pswd" -in "$src" -out "$dest" &>/dev/null; then
      lerror "Failed to decrypt $(lscolor "$src")"
      return 1
    fi
  else
    lwarn "Cannot decrypt $(lscolor "$src"), must be a file"
    return 1
  fi
  echo "$dest"
  return 0
}

fs_resolve() {
  while true; do
    action="$(pselect "How do you want to resolve the conflict" "Keep the dotfile version;Keep the system version;Compare the two for differences;Skip it")"
    if [ -z "$action" ]; then
      return 0
    elif [ "$action" == "Keep the dotfile version" ]; then
      echo "dotfile"
      return 0
    elif [ "$action" == "Keep the system version" ]; then
      echo "sysfile"
      return 0
    elif [ "$action" == "Compare the two for differences" ]; then
      diff --minimal --recursive --color=auto "$1" "$2" 1>&2
    elif [ "$action" == "Skip it" ]; then
      echo "skip"
      return 0
    fi
  done
}

# src/lib/sample_function.sh
sample_function() {
  echo "it works"
}

# src/lib/semver.sh
#!/usr/bash

semver_eq() {
  vera="$1"
  verb="$2"

  majora="${vera%%.*}"
  majorb="${verb%%.*}"

  minora="${vera#*.}"
  minora="${minora%%.*}"
  minorb="${verb#*.}"
  minorb="${minorb%%.*}"
  patcha="${vera##*.}"
  patchb="${verb##*.}"

  if [ "$majora" -eq "$majorb" ] && [ "$minora" -eq "$minorb" ] && [ "$patcha" -eq "$patchb" ]; then
    return 0
  else
    return 1
  fi
}

semver_gt() {
  vera="$1"
  verb="$2"

  majora="${vera%%.*}"
  majorb="${verb%%.*}"

  minora="${vera#*.}"
  minora="${minora%%.*}"
  minorb="${verb#*.}"
  minorb="${minorb%%.*}"
  patcha="${vera##*.}"
  patchb="${verb##*.}"

  if [ "$majora" -gt "$majorb" ]; then
    return 0
  elif [ "$majora" -eq "$majorb" ] && [ "$minora" -gt "$minorb" ]; then
    return 0
  elif [ "$majora" -eq "$majorb" ] && [ "$minora" -eq "$minorb" ] && [ "$patcha" -gt "$patchb" ]; then
    return 0
  else
    return 1
  fi
}

# src/lib/send_completions.sh
send_completions() {
  echo $'#!/usr/bin/env bash'
  echo $''
  echo $'# This bash completions script was generated by'
  echo $'# completely (https://github.com/dannyben/completely)'
  echo $'# Modifying it manually is not recommended'
  echo $'_dotm_completions() {'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local comp_line="${COMP_WORDS[@]:1}"'
  echo $''
  echo $'  case "$comp_line" in'
  echo $'    \'completions\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'install\'*) COMPREPLY=($(compgen -W "--force --help -f -h" -- "$cur")) ;;'
  echo $'    \'update\'*) COMPREPLY=($(compgen -W "--check --force --help --no-completion --no-dotm --path --url -C -D -U -c -f -h -p" -- "$cur")) ;;'
  echo $'    \'remove\'*) COMPREPLY=($(compgen -W "--force --help --package -f -h -p" -- "$cur")) ;;'
  echo $'    \'unset\'*) COMPREPLY=($(compgen -W "--force --help -f -h" -- "$cur")) ;;'
  echo $'    \'list\'*) COMPREPLY=($(compgen -W "--all --help --raw -a -h -r" -- "$cur")) ;;'
  echo $'    \'pull\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'push\'*) COMPREPLY=($(compgen -W "--help --message -h -m" -- "$cur")) ;;'
  echo $'    \'sync\'*) COMPREPLY=($(compgen -W "--help --max-frequnecy --message -f -h -m" -- "$cur")) ;;'
  echo $'    \'add\'*) COMPREPLY=($(compgen -W "--archive --copy --encrypt --force --help --package -a -c -e -f -h -p" -- "$cur")) ;;'
  echo $'    \'set\'*) COMPREPLY=($(compgen -W "--force --help -f -h" -- "$cur")) ;;'
  echo $'    \'\'*) COMPREPLY=($(compgen -W "--help --version -h -v add completions install list pull push remove set sync unset update" -- "$cur")) ;;'
  echo $'  esac'
  echo $'}'
  echo $''
  echo $'complete -F _dotm_completions dotm'
}

# src/lib/ui/colors.sh
#!/bin/bash

ENABLE_COLOR=false

configure_color() {
  if [ -z ${NO_COLOR+x} ] && [ "$1" == "true" ]; then
    ENABLE_COLOR=true
  else
    ENABLE_COLOR=false
  fi
}

print_in_color() {
  local color="$1"
  shift
  if [ "$ENABLE_COLOR" == true ]; then
    if [ "$UNIT_TESTS" == true ]; then
      printf "\\$color%b\\\e[0m\n" "$*"
    else
      printf "$color%b\e[0m\n" "$*"
    fi
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underline() { print_in_color "\e[4m" "$*"; }
redBold() { print_in_color "\e[1;31m" "$*"; }
greenBold() { print_in_color "\e[1;32m" "$*"; }
yellowBold() { print_in_color "\e[1;33m" "$*"; }
blueBold() { print_in_color "\e[1;34m" "$*"; }
magentaBold() { print_in_color "\e[1;35m" "$*"; }
cyanBold() { print_in_color "\e[1;36m" "$*"; }
redUnderline() { print_in_color "\e[4;31m" "$*"; }
greenUnderline() { print_in_color "\e[4;32m" "$*"; }
yellowUnderline() { print_in_color "\e[4;33m" "$*"; }
blueUnderline() { print_in_color "\e[4;34m" "$*"; }
magentaUnderline() { print_in_color "\e[4;35m" "$*"; }
cyanUnderline() { print_in_color "\e[4;36m" "$*"; }
redBoldUnderline() { print_in_color "\e[4;31m" "$*"; }
greenBoldUnderline() { print_in_color "\e[1;4;32m" "$*"; }
yellowBoldUnderline() { print_in_color "\e[1;4;33m" "$*"; }
blueBoldUnderline() { print_in_color "\e[1;4;34m" "$*"; }
magentaBoldUnderline() { print_in_color "\e[1;4;35m" "$*"; }
cyanBoldUnderline() { print_in_color "\e[1;4;36m" "$*"; }

lscolor() {
  if [ "$ENABLE_COLOR" == true ]; then
    while IFS= read -r line; do
      local key="${line%%=*}"
      local value="${line##*=}"
      if [[ "$1" == $key ]]; then
        if [ "$UNIT_TESTS" == true ]; then
          printf '%b%s%b\n' "\\\e[${value}m" "$1" "\\\e[0m"
        else
          printf '%b%s%b\n' "\e[${value}m" "$1" "\e[0m"
        fi
        return 0
      fi
    done <<<"$(echo "$LS_COLORS" | tr ":" "\n")"
    green "$1"
  else
    printf '%s\n' "$1"
  fi
}

# src/lib/ui/logging.sh
#!/bin/bash

LOG_LEVEL=0

configure_logging() {
  case "$1" in
    trace) LOG_LEVEL=0;;
    debug) LOG_LEVEL=1;;
    info) LOG_LEVEL=2;;
    warning) LOG_LEVEL=3;;
    error) LOG_LEVEL=4;;
  esac
}

_log() {
  local prefix=""
  case "$1" in
    trace) [ $LOG_LEVEL -gt 0 ] && return 0; prefix="$(cyanBold "T")";;
    debug) [ $LOG_LEVEL -gt 1 ] && return 0; prefix="$(magentaBold "D")";;
    info) [ $LOG_LEVEL -gt 2 ] && return 0; prefix="$(greenBold "I")";;
    warning) [ $LOG_LEVEL -gt 3 ] && return 0; prefix="$(yellowBold "W")";;
    error) [ $LOG_LEVEL -gt 4 ] && return 0; prefix="$(redBold "E")";;
  esac
  shift
  printf "[%b] %b\n" "$prefix" "$*" >&2
}

ltrace() { _log trace "$@"; }
ldebug() { _log debug "$@"; }
linfo() { _log info "$@"; }
lwarn() { _log warning "$@"; }
lerror() { _log error "$@"; }

# src/lib/ui/prompts.sh
#!/bin/bash

IS_TTY=false
[ -t 1 ] && IS_TTY=true
INTERACTIVE=false

configure_prompts() {
  if [ "$1" == true ]; then
    INTERACTIVE=true
  else
    INTERACTIVE=false
  fi
}

pconfirm() {
  local default=""
  if [ -n "$2" ]; then
    if [ "$2" == true ]; then
      default=true
    else
      default=false
    fi
  fi

  if [ "$INTERACTIVE" == false ]; then
    if [ "$default" == true ]; then
      return 0
    else
      return 1
    fi
  fi

  local prompt="$(cyanBold ">>>") $1"
  if [ "$default" == true ]; then
    prompt="$prompt $(bold "[Y/n]")"
  elif [ "$default" == false ]; then
    prompt="$prompt $(bold "[y/N]")"
  else
    prompt="$prompt $(bold "[y/n]")"
  fi

  while true; do
    read -n 1 -rp "$prompt: "
    case "$REPLY" in
    [YyNn]*) break ;;
    '')
      [ -n "$default" ] && break
      printf "    %b An input is required, enter 'y' or 'n'\n" "$(redBold ">")" 1>&2
      ;;
    *) printf "\n    %b Input must be 'y' or 'n', not '%s'\n" "$(redBold ">")" "$REPLY" 1>&2 ;;
    esac

    if [ "$IS_TTY" == true ]; then
      printf "\e[2A\e[2K" 1>&2
    fi
  done
  [ -n "$REPLY" ] && printf '\n' 1>&2
  [ "$IS_TTY" == true ] && printf "\e[2K" 1>&2

  case "$REPLY" in
  [Yy]*) return 0 ;;
  [Nn]*) return 1 ;;
  *) [ "$default" == true ] && return 0 || return 1 ;;
  esac
}

pv_not_empty() {
  [ -z "$1" ] && echo "Input must not be empty"
}

pv_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "Input must be an integer"
}

pinput() {
  local prompt="$(cyanBold ">>>") $1"
  local default="$2"
  local validation="$3"

  if [ "$INTERACTIVE" == false ]; then
    echo "$default"
    return 0
  fi

  if [ -n "$default" ]; then
    prompt="$prompt $(bold "[$default]")"
  fi

  while true; do
    read -rp "$prompt: "

    if [ -z "$REPLY" ] && [ -n "$default" ]; then
      break
    elif [ -n "$validation" ]; then
      response="$($validation "$REPLY")"
      if [ -z "$response" ]; then
        break
      else
        printf "    %b %s\n" "$(redBold ">")" "$response" 1>&2
      fi
    else
      break
    fi

    if [ "$IS_TTY" == true ]; then
      printf "\e[2A\e[2K" 1>&2
    fi
  done
  [ "$IS_TTY" == true ] && printf "\e[2K" 1>&2

  if [ -z "$REPLY" ] && [ -n "$default" ]; then
    echo "$default"
  else
    echo "$REPLY"
  fi
}

ppassword() {
  local prompt="$(cyanBold ">>>") $1"

  if [ "$INTERACTIVE" == false ]; then
    return 0
  fi

  while true; do
    read -srp "$prompt: "

    if [ -z "$REPLY" ]; then
      printf "\n    %b %s\n" "$(redBold ">")" "Input must not be empty" 1>&2
    else
      break
    fi

    if [ "$IS_TTY" == true ]; then
      printf "\e[2A\e[2K" 1>&2
    fi
  done
  printf "\n" 1>&2
  [ "$IS_TTY" == true ] && printf "\e[2K" 1>&2

  echo "$REPLY"
}

pselect() {
  local prompt="$(cyanBold ">>>") $1"
  IFS=';' read -ra options <<<"$2"
  local default="$3"

  if [ "$INTERACTIVE" == false ]; then
    [ -n "$default" ] && echo "${options[$default]}"
    return 0
  fi

  if [ -n "$default" ]; then
    prompt="$prompt $(bold "[$((default + 1))]")"
  fi

  for i in $(seq 1 ${#options[@]}); do
    local id=$((i - 1))
    printf "    %b%b %b\n" "$(blueBold "$i")" "$(bold ")")" "${options[$id]}" 1>&2
  done

  while true; do
    read -rp "$prompt: "

    if [ -z "$REPLY" ] && [ -n "$default" ]; then
      break
    elif ! [[ "$REPLY" =~ ^[0-9]+$ ]]; then
      printf "    %b %s\n" "$(redBold ">")" "Input must be an integer between 1 and ${#options[@]}" 1>&2
    elif [ "$REPLY" -le 0 ] || [ "$REPLY" -gt "${#options[@]}" ]; then
      printf "    %b %s\n" "$(redBold ">")" "Input must be an integer between 1 and ${#options[@]}" 1>&2
    else
      break
    fi

    if [ "$IS_TTY" == true ]; then
      printf "\e[2A\e[2K" 1>&2
    fi
  done
  [ "$IS_TTY" == true ] && printf "\e[2K" 1>&2

  if [ -z "$REPLY" ] && [ -n "$default" ]; then
    echo "${options[$default]}"
  else
    REPLY=$((REPLY - 1))
    echo "${options[$REPLY]}"
  fi
}

# src/lib/validations/validate_dir_exists.sh
validate_dir_exists() {
  [[ -d "$1" ]] || echo "must be an existing directory"
}

# src/lib/validations/validate_file_exists.sh
validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

# src/lib/validations/validate_integer.sh
validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

# src/lib/validations/validate_not_empty.sh
validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

# :command.command_functions
# :command.function
dotm_completions_command() {
  # src/completions_command.sh
  send_completions
}

# :command.function
dotm_update_command() {
  # src/update_command.sh
  #!/bin/bash

  remote_source=""
  remote_source="$(curl -s "${args[--url]}/dotm")"
  if [ $? -ne 0 ]; then
    lerror "Failed to fetch remote version of dotm from $(magentaBold "${args[--url]}/dotm")"
  fi

  remote_version="$(echo "$remote_source" | grep "^\s*version=")"
  remote_version="${remote_version##*=}"
  remote_version="${remote_version//\"/}"

  dotm_path="${args[--path]}"
  dotm_path="${dotm_path:-$SCRIPT_DIR}/dotm"
  dotm_path="${dotm_path//\/\//\/}"
  if [ -e "$dotm_path" ]; then
    local_version="$(grep "^\s*version=" "$dotm_path")"
    local_version="${local_version##*=}"
    local_version="${local_version//\"/}"
  else
    local_version="0.0.0"
  fi

  can_update=false
  if semver_eq "$remote_version" "$local_version"; then
    linfo "$(bold "dotm") is already up to date $(yellowBold "v$remote_version")"
  elif semver_gt "$remote_version" "$local_version"; then
    linfo "A newer version of $(bold "dotm") is available $(yellowBold "v$local_version") -> $(yellowBold "v$remote_version")"
    can_update=true
  else
    linfo "A newer version of $(bold "dotm") is already installed $(yellowBold "v$local_version") -> $(yellowBold "v$remote_version")"
  fi

  if [ -n "${args[--check]}" ]; then
    exit 0
  fi

  if [ -n "${args[--force]}" ]; then
    can_update=true
  fi

  if [ "$can_update" == true ] && [ -z "${args[--no - dotm]}" ]; then
    if [ -n "${args[--force]}" ] || pconfirm "Are you sure you want to update dotm"; then
      ldebug "Installing $(bold "dotm") into $(lscolor "$dotm_path")"
      [ -f "$dotm_path" ] && rm -f "$dotm_path"
      echo "$remote_source" >"$dotm_path"
      chmod +x "$dotm_path"

      linfo "Updated $(bold "dotm") $(yellowBold "v$local_version") -> $(yellowBold "v$remote_version")"

      if ! [[ ":$PATH:" == *":${args[--path]}:"* ]]; then
        lwarn "The installation path $(lscolor "${args[--path]}") is not in your \$PATH, be sure to add it."
      fi
    fi
  fi

  if [ "$can_update" == true ] && [ -z "${args[--no - completion]}" ]; then
    if [ -n "${args[--force]}" ] || pconfirm "Are you sure you want to update dotm completions"; then
      completion_path="${XDG_DATA_HOME:-$HOME/.local/share}/bash-completions/completions/dotm.bash"
      ldebug "Installing $(bold "dotm completions") into $(lscolor "$completion_path")"
      [ -f "$completion_path" ] && rm -f "$completion_path"
      curl -s "${args[--url]}/completions.bash" -o "$completion_path"

      linfo "Updated $(bold "dotm completions") $(yellowBold "v$local_version") -> $(yellowBold "v$remote_version")"
    fi
  fi
}

# :command.function
dotm_add_command() {
  # src/add_command.sh
  #!/bin/bash

  section="$(config_get "$CONFIG_FILE" "${args[--package]}" || true)"
  PSWD=""

  for file in ${args[files]}; do
    file="${file//\"/}"
    file="$(fs_expanduser "$file")"

    if [ -e "$file" ]; then
      if [ -d "$file" ]; then type="directory"; else type="file"; fi

      sysfile="$(realpath "$file")"
      dotfile="$(fs_dotfile "$file" "${args[--package]}")"

      if [[ "$sysfile" = "$DOTFILES/"* ]]; then
        lwarn "The $type $(lscolor "$file") is already tracked in the dotfiles, it will be skipped"
        continue
      fi

      action=""
      if [ -e "$dotfile" ]; then
        if [ -n "${args[--force]}" ]; then
          rm -rf "$dotfile"
        elif [ "$(fs_hash "$dotfile")" = "$(fs_hash "$sysfile")" ]; then
          lwarn "A duplicate of this $type is already in the dotfiles"
          continue
        else
          lwarn "The $type $(lscolor "$dotfile") in the dotfiles differs from $type $(lscolor "$file")"
          action="$(fs_resolve "$dotfile" "$sysfile")"
          if [ "$action" == "skip" ] || [ -z "$action" ]; then
            continue
          elif [ "$action" == "sysfile" ]; then
            rm -rf "$dotfile"
          fi
        fi
      fi

      should_copy=false
      should_archive=false
      should_encrypt=false
      if [ -n "${args[--copy]}" ]; then
        should_copy=true
      fi
      if [ -n "${args[--archive]}" ]; then
        should_archive=true
        should_copy=true
      fi
      if [ -n "${args[--encrypt]}" ]; then
        should_encrypt=true
        should_copy=true
        if [ -d "$sysfile" ]; then
          should_archive=true
        fi
      fi

      attributes=""
      archived=""
      if [ "$should_archive" == true ]; then
        attributes="${attributes}X"
        archived="$(fs_archive "$sysfile")"
        if [ $? -ne 0 ]; then
          continue
        fi
        sysfile="$archived"
      fi

      encrypted=""
      if [ "$should_encrypt" == true ]; then
        attributes="${attributes}E"
        if [ -z "$PSWD" ]; then
          PSWD="$(ppassword "Enter encryption password")"
        fi
        encrypted="$(fs_encrypt "$PSWD" "$sysfile")"
        if [ $? -ne 0 ]; then
          [ -e "$archived" ] && rm -f "$archived"
          continue
        fi
        sysfile="$encrypted"
      fi

      [ -d "$(dirname "$dotfile")" ] || mkdir -p "$(dirname "$dotfile")"
      if [ "$should_copy" == true ]; then
        attributes="${attributes}C"
        cp -r "$sysfile" "$dotfile"
      else
        mv "$sysfile" "$dotfile"

        if [ -e "$file" ] && [ "$action" == "dotfile" ]; then
          rm -rf "$file"
        elif ! [ -e "$file" ]; then
          ln -s "$dotfile" "$file"
        fi
      fi

      [ -e "$encrypted" ] && rm -f "$encrypted"
      [ -e "$archived" ] && rm -f "$archived"

      if [ -n "$attributes" ]; then attributes="${attributes}:"; fi

      section="$(section_set "$section" "${attributes}$(fs_reldot "$dotfile")" "$(fs_reluser "$file")")"
      linfo "Added the $type $(lscolor "$file") to the $(bold "${args[--package]}") package"
    elif config_has "$CONFIG_FILE" "$file"; then
      depends="$(section_get "$section" "depends" || true)"
      if [[ " $depends " = *" $file "* ]]; then
        lwarn "Package $(bold "$file") is already a dependency of $(bold "${args[--package]}")"
      else
        section="$(section_set "$section" "depends" "$depends $file")"
        linfo "Added $(bold "$file") as a dependency of $(bold "${args[--package]}")"
      fi
    else
      lwarn "File or directory $(lscolor "$file") does not exist, it will be skipped"
    fi
  done

  config_set "$CONFIG_FILE" "${args[--package]}" "$section"
}

# :command.function
dotm_install_command() {
  # src/install_command.sh
  echo "# this file is located in 'src/install_command.sh'"
  echo "# code for 'dotm install' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args
}

# :command.function
dotm_list_command() {
  # src/list_command.sh
  echo "# this file is located in 'src/list_command.sh'"
  echo "# code for 'dotm list' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args
}

# :command.function
dotm_remove_command() {
  # src/remove_command.sh
  echo "# this file is located in 'src/remove_command.sh'"
  echo "# code for 'dotm remove' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args
}

# :command.function
dotm_set_command() {
  # src/set_command.sh
  #!/bin/bash

  config_resolve "$CONFIG_FILE" "${args[--package]}"
}

# :command.function
dotm_unset_command() {
  # src/unset_command.sh
  echo "# this file is located in 'src/unset_command.sh'"
  echo "# code for 'dotm unset' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args
}

# :command.function
dotm_pull_command() {
  # src/pull_command.sh
  #!/bin/bash

  ldebug "Pulling changes from remote dotfiles repo"
  if ! git -C "$DOTFILES" pull --rebase &>/dev/null; then
    lerror "Failed to pull remote changes into local dotfiles repo $(lscolor "$DOTFILES")"
    exit 1
  fi
}

# :command.function
dotm_push_command() {
  # src/push_command.sh
  #!/bin/bash

  if [ -n "$(git -C "$DOTFILES" status --porcelain)" ]; then
    ldebug "Commiting local changes"
    if ! git -C "$DOTFILES" add -A &>/dev/null; then
      lerror "Failed to add local changes to the git repo"
      exit 1
    fi

    if ! git -C "$DOTFILES" commit -m "${args[--message]}"; then
      lerror "Failed to create commit local changes"
      exit 1
    fi

    if ! git -C "$DOTFILES" push; then
      lerror "Failed to push local commits to remote repository"
      exit 1
    fi
  else
    lwarn "No local changes, no commit will be made"
  fi
}

# :command.function
dotm_sync_command() {
  # src/sync_command.sh
  #!/bin/bash

  # TODO: Implement frequency cache to limit sync occurances

  has_local_commit=false
  if [ -n "$(git -C "$DOTFILES" status --porcelain)" ]; then
    ldebug "Commiting local changes"
    if ! git -C "$DOTFILES" add -A &>/dev/null; then
      lerror "Failed to add local changes to the git repo"
      exit 1
    fi

    if ! git -C "$DOTFILES" commit -m "${args[--message]}"; then
      lerror "Failed to create commit local changes"
      exit 1
    fi

    has_local_commit=true
  else
    lwarn "No local changes, no new commit will be made"
  fi

  if ! git -C "$DOTFILES" pull --rebase; then
    lerror "Failed to pull remote changes into local dotfiles $(lscolor "$DOTFILES")"
    exit 1
  fi

  # TODO: Add configuration to run the set command to update dotfiles

  if [ "$has_local_commit" == true ]; then
    if ! git -C "$DOTFILES" push; then
      lerror "Failed to push local commits to remote repository"
      exit 1
    fi
  fi
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --version | -v )
    version_command
    exit
    ;;

  --help | -h )
    long_usage=yes
    dotm_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  export DOTFILES="${DOTFILES:-$HOME/dotfiles.new}"
  if [[ -z "${DOTFILES:-}" ]]; then
    printf "missing required environment variable: DOTFILES\n"
    exit 1
  fi
  # :command.dependencies_filter
  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  completions | C )
    action="completions"
    shift
    dotm_completions_parse_requirements "$@"
    shift $#
    ;;

  update | U )
    action="update"
    shift
    dotm_update_parse_requirements "$@"
    shift $#
    ;;

  add | a )
    action="add"
    shift
    dotm_add_parse_requirements "$@"
    shift $#
    ;;

  install | i )
    action="install"
    shift
    dotm_install_parse_requirements "$@"
    shift $#
    ;;

  list | l )
    action="list"
    shift
    dotm_list_parse_requirements "$@"
    shift $#
    ;;

  remove | r )
    action="remove"
    shift
    dotm_remove_parse_requirements "$@"
    shift $#
    ;;

  set | s )
    action="set"
    shift
    dotm_set_parse_requirements "$@"
    shift $#
    ;;

  unset | u )
    action="unset"
    shift
    dotm_unset_parse_requirements "$@"
    shift $#
    ;;

  pull )
    action="pull"
    shift
    dotm_pull_parse_requirements "$@"
    shift $#
    ;;

  push )
    action="push"
    shift
    dotm_push_parse_requirements "$@"
    shift $#
    ;;

  sync )
    action="sync"
    shift
    dotm_sync_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  * )
    dotm_usage
    exit 1
    ;;

  esac
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dotm_completions_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dotm_completions_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="completions"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dotm_update_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dotm_update_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  if ! [[ -x "$(command -v curl)" ]]; then
    printf "missing dependency: curl\n"
    exit 1
  fi
  # :command.command_filter
  action="update"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --force | -f )
      # :flag.conflicts
      if [[ -n "${args[--check]:-}" ]]; then
        printf "conflicting options: %s cannot be used with %s\n" "$key" "--check"
        exit 1
      fi
      args[--force]=1
      shift
      ;;

    # :flag.case
    --check | -c )
      # :flag.conflicts
      for conflict in --force --no-completion --no-dotm; do
        if [[ -n "${args[$conflict]:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "$conflict"
          exit 1
        fi
      done
      args[--check]=1
      shift
      ;;

    # :flag.case
    --no-completion | -C )
      # :flag.conflicts
      if [[ -n "${args[--check]:-}" ]]; then
        printf "conflicting options: %s cannot be used with %s\n" "$key" "--check"
        exit 1
      fi
      args[--no-completion]=1
      shift
      ;;

    # :flag.case
    --no-dotm | -D )
      # :flag.conflicts
      if [[ -n "${args[--check]:-}" ]]; then
        printf "conflicting options: %s cannot be used with %s\n" "$key" "--check"
        exit 1
      fi
      args[--no-dotm]=1
      shift
      ;;

    # :flag.case
    --url | -U )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--url]="$2"
        shift
        shift
      else
        printf "%s\n" "--url requires an argument: --url, -U URL"
        exit 1
      fi
      ;;

    # :flag.case
    --path | -p )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        if [[ -n $(validate_dir_exists "$2") ]]; then
          printf "validation error in %s:\n%s\n" "--path, -p PATH" "$(validate_dir_exists "$2")"
          exit 1
        fi
        args[--path]="$2"
        shift
        shift
      else
        printf "%s\n" "--path requires an argument: --path, -p PATH"
        exit 1
      fi
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  [[ -n ${args[--url]:-} ]] || args[--url]="https://raw.githubusercontent.com/LuxAter/dotm/main"
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dotm_add_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dotm_add_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="add"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --force | -f )
      # :flag.conflicts
      args[--force]=1
      shift
      ;;

    # :flag.case
    --package | -p )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--package]="$2"
        shift
        shift
      else
        printf "%s\n" "--package requires an argument: --package, -p PACKAGE"
        exit 1
      fi
      ;;

    # :flag.case
    --encrypt | -e )
      # :flag.conflicts
      args[--encrypt]=1
      shift
      ;;

    # :flag.case
    --copy | -c )
      # :flag.conflicts
      args[--copy]=1
      shift
      ;;

    # :flag.case
    --archive | -a )
      # :flag.conflicts
      args[--archive]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[files]+x} ]]; then
        # :argument.validations
        args[files]="\"$1\""
        shift
      else
        args[files]="${args[files]} \"$1\""
        shift
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[files]+x} ]]; then
    printf "missing required argument: FILES\nusage: dotm add FILES... [options]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  [[ -n ${args[--package]:-} ]] || args[--package]="host/$HOSTNAME"
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dotm_install_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dotm_install_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="install"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --force | -f )
      # :flag.conflicts
      args[--force]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[packages]+x} ]]; then
        # :argument.validations
        args[packages]="\"$1\""
        shift
      else
        args[packages]="${args[packages]} \"$1\""
        shift
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  [[ -n ${args[packages]:-} ]] || args[packages]="host/$HOSTNAME"
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dotm_list_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dotm_list_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="list"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --all | -a )
      # :flag.conflicts
      args[--all]=1
      shift
      ;;

    # :flag.case
    --raw | -r )
      # :flag.conflicts
      args[--raw]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[packages]+x} ]]; then
        # :argument.validations
        args[packages]="\"$1\""
        shift
      else
        args[packages]="${args[packages]} \"$1\""
        shift
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  [[ -n ${args[packages]:-} ]] || args[packages]="host/$HOSTNAME"
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dotm_remove_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dotm_remove_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="remove"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --force | -f )
      # :flag.conflicts
      args[--force]=1
      shift
      ;;

    # :flag.case
    --package | -p )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--package]="$2"
        shift
        shift
      else
        printf "%s\n" "--package requires an argument: --package, -p PACKAGE"
        exit 1
      fi
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[files]+x} ]]; then
        # :argument.validations
        args[files]="\"$1\""
        shift
      else
        args[files]="${args[files]} \"$1\""
        shift
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[files]+x} ]]; then
    printf "missing required argument: FILES\nusage: dotm remove FILES... [options]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  [[ -n ${args[--package]:-} ]] || args[--package]="host/$HOSTNAME"
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dotm_set_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dotm_set_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="set"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --force | -f )
      # :flag.conflicts
      args[--force]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[packages]+x} ]]; then
        # :argument.validations
        args[packages]="\"$1\""
        shift
      else
        args[packages]="${args[packages]} \"$1\""
        shift
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  [[ -n ${args[packages]:-} ]] || args[packages]="host/$HOSTNAME"
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dotm_unset_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dotm_unset_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="unset"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --force | -f )
      # :flag.conflicts
      args[--force]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[packages]+x} ]]; then
        # :argument.validations
        args[packages]="\"$1\""
        shift
      else
        args[packages]="${args[packages]} \"$1\""
        shift
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  [[ -n ${args[packages]:-} ]] || args[packages]="host/$HOSTNAME"
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dotm_pull_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dotm_pull_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="pull"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dotm_push_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dotm_push_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="push"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --message | -m )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--message]="$2"
        shift
        shift
      else
        printf "%s\n" "--message requires an argument: --message, -m MESSAGE"
        exit 1
      fi
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  [[ -n ${args[--message]:-} ]] || args[--message]="$(date +"%Y-%m-%d %H:%M:%S")"
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dotm_sync_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dotm_sync_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="sync"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --max-frequnecy | -f )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--max-frequnecy]="$2"
        shift
        shift
      else
        printf "%s\n" "--max-frequnecy requires an argument: --max-frequnecy, -f DURATION"
        exit 1
      fi
      ;;

    # :flag.case
    --message | -m )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--message]="$2"
        shift
        shift
      else
        printf "%s\n" "--message requires an argument: --message, -m MESSAGE"
        exit 1
      fi
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  [[ -n ${args[--message]:-} ]] || args[--message]="$(date +"%Y-%m-%d %H:%M:%S")"
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.initialize
initialize() {
  version="0.1.5"
  long_usage=''
  set -e

  # src/initialize.sh
  #!/bin/bash

  SCRIPT_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)
  CONFIG_FILE="$DOTFILES/dot.ini"

  [ -t 1 ] && configure_color true
  [ -t 1 ] && configure_prompts true
  configure_logging info
  [ -t 1 ] || configure_logging debug
}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  if [[ $action == "completions" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dotm_completions_usage
    else
      dotm_completions_command
    fi

  elif [[ $action == "update" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dotm_update_usage
    else
      dotm_update_command
    fi

  elif [[ $action == "add" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dotm_add_usage
    else
      dotm_add_command
    fi

  elif [[ $action == "install" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dotm_install_usage
    else
      dotm_install_command
    fi

  elif [[ $action == "list" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dotm_list_usage
    else
      dotm_list_command
    fi

  elif [[ $action == "remove" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dotm_remove_usage
    else
      dotm_remove_command
    fi

  elif [[ $action == "set" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dotm_set_usage
    else
      dotm_set_command
    fi

  elif [[ $action == "unset" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dotm_unset_usage
    else
      dotm_unset_command
    fi

  elif [[ $action == "pull" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dotm_pull_usage
    else
      dotm_pull_command
    fi

  elif [[ $action == "push" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dotm_push_usage
    else
      dotm_push_command
    fi

  elif [[ $action == "sync" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dotm_sync_usage
    else
      dotm_sync_command
    fi

  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
