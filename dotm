#!/usr/bin/env bash
# This script was generated by bashly 0.7.9 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n"
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
dotm_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotm - Personal dotfiles manager utility\n"
    echo

  else
    printf "dotm - Personal dotfiles manager utility\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dotm [command]\n"
  printf "  dotm [command] --help | -h\n"
  printf "  dotm --version | -v\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  add   Add new files/directories to the dotfiles"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "Environment Variables:\n"

    # :environment_variable.usage
    echo "  DOTFILES (required)"
    printf "    Path to the local dotfiles repository\n"
    printf "    Default: $HOME/dotfiles.new/\n"
    echo

  fi
}

# :command.usage
dotm_add_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotm add - Add new files/directories to the dotfiles\n"
    echo

  else
    printf "dotm add - Add new files/directories to the dotfiles\n"
    echo

  fi

  printf "Shortcut: a\n"
  echo

  printf "Usage:\n"
  printf "  dotm add FILE... [options]\n"
  printf "  dotm add --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --package, -p PACKAGE"
    printf "    Set the package to contain the new files\n"
    printf "    Default: host/$HOSTNAME\n"
    echo

    # :flag.usage
    echo "  --encrypt, -e"
    printf "    Encrypt the file/directories in the dotfiles\n"
    echo

    # :flag.usage
    echo "  --copy, -c"
    printf "    Copy the dotfiles instead of using links\n"
    echo

    # :flag.usage
    echo "  --archive, -a"
    printf "    Compress the file/directories into a tarball in the dotfiles\n"
    echo

    # :flag.usage
    echo "  --force, -f"
    printf "    Force overwriting duplicate dotfiles\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  FILE..."
    printf "    Files/Directories to import into the dotfiles repo\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for (( i=0 ; i < ${#flags} ; i++ )); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if (( ${#args[@]} )); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if (( ${#other_args[@]} )); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# src/lib/color.sh
#!/bin/bash

if [[ -z ${NO_COLOR+x} ]] && [[ -t 1 ]]; then
  ENABLE_COLOR=true
else
  ENABLE_COLOR=false
fi

print_in_color() {
  local color="$1"
  shift
  if [[ $ENABLE_COLOR == true ]]; then
    printf "$color%b\e[0m\n" "$*";
  else
    printf "%b\n" "$*";
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
redBold() { print_in_color "\e[1;31m" "$*"; }
greenBold() { print_in_color "\e[1;32m" "$*"; }
yellowBold() { print_in_color "\e[1;33m" "$*"; }
blueBold() { print_in_color "\e[1;34m" "$*"; }
magentaBold() { print_in_color "\e[1;35m" "$*"; }
cyanBold() { print_in_color "\e[1;36m" "$*"; }
redUnderlined() { print_in_color "\e[4;31m" "$*"; }
greenUnderlined() { print_in_color "\e[4;32m" "$*"; }
yellowUnderlined() { print_in_color "\e[4;33m" "$*"; }
blueUnderlined() { print_in_color "\e[4;34m" "$*"; }
magentaUnderlined() { print_in_color "\e[4;35m" "$*"; }
cyanUnderlined() { print_in_color "\e[4;36m" "$*"; }
redBoldUnderlined() { print_in_color "\e[4;31m" "$*"; }
greenBoldUnderlined() { print_in_color "\e[1;4;32m" "$*"; }
yellowBoldUnderlined() { print_in_color "\e[1;4;33m" "$*"; }
blueBoldUnderlined() { print_in_color "\e[1;4;34m" "$*"; }
magentaBoldUnderlined() { print_in_color "\e[1;4;35m" "$*"; }
cyanBoldUnderlined() { print_in_color "\e[1;4;36m" "$*"; }

lscolor() {
  if [[ $ENABLE_COLOR == true ]]; then
    while IFS= read -r line; do
      local key="${line%%=*}"
      local value="${line##*=}"
      if [[ "$1" == $key ]]; then
        printf '%b%s%b\n' "\e[${value}m" "$1" "\e[0m"
        return 0
      fi
    done <<<"$(echo "$LS_COLORS" | tr ":" "\n")"
    printf '%b\n' "$(green "$1")"
  else
    printf '%s\n' "$1"
  fi
}

# src/lib/config.sh
#!/bin/bash

CONFIG_FILE=""

config_init() {
  CONFIG_FILE="$1"
  if ! [[ -f "$CONFIG_FILE" ]]; then
    if ! [[ -d "$(dirname "$CONFIG_FILE")" ]]; then
      linfo "Creating new local dotfiles repo $(lscolor "$(dirname "$CONFIG_FILE")")"
      mkdir -p "$(dirname "$CONFIG_FILE")"
    fi
    linfo "Creating new empty config file $(lscolor "$CONFIG_FILE")"
    touch "$CONFIG_FILE"
  fi
}

CONFIG_SECTION_KEY=""
CONFIG_SECTION=""


config_get() {
  CONFIG_SECTION_KEY="$1"
  CONFIG_SECTION=""

  local found=false
  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ ^\[(.+)\]$ ]]; then
      if [[ "${BASH_REMATCH[1]}" == "$1" ]]; then
        found=true
      elif [[ $found == true ]]; then
        break
      fi
    elif [[ $found == true ]]; then
      CONFIG_SECTION="$CONFIG_SECTION$line\n"
    fi
  done < "$CONFIG_FILE"
}

config_set() {
  local key="${1:-$CONFIG_SECTION_KEY}"
  local body="${2:-$CONFIG_SECTION}"

  local copy=true
  local found=false
  local output=""
  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ ^\[(.+)\]$ ]]; then
      if [[ "${BASH_REMATCH[1]}" == "$key" ]]; then
        found=true
        copy=false
        output="${output}[$key]\n$body"
      else
        output="$output$line\n"
        copy=true
      fi
    elif [[ $copy == true ]]; then
      output="$output$line\n"
    fi
  done < "$CONFIG_FILE"

  if [[ $found == false ]]; then
    if [[ "$key" =~ ^host/* ]]; then
      output="[$key]\n$body$output"
    else
      output="${output}[$key]\n$body"
    fi
  fi

  printf "%b" "$output" > "$CONFIG_FILE"
}

config_del() {
  local key="$1"

  local output=""
  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ ^\[(.+)\]$ ]]; then
      if [[ "${BASH_REMATCH[1]}" == "$key" ]]; then
        copy=false
      else
        output="$output$line\n"
        copy=true
      fi
    elif [[ $copy == true ]]; then
      output="$output$line\n"
    fi
  done < "$CONFIG_FILE"

  printf "%b" "$output" > "$CONFIG_FILE"
}

config_keys() {
  local keys=()
  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ ^\[([A-Za-z0-9/]+)\]$ ]]; then
      keys+=("${BASH_REMATCH[1]}")
    fi
  done < "$CONFIG_FILE"
  echo "${keys[@]}"
}

config_has() {
  [[ " $(config_keys) " =~ " $1 " ]]
}


section_get() {
  local key="$1"
  local body="${2:-$CONFIG_SECTION}"

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ ^$key\s*=\s*(.+)\s*$ ]]; then
      echo "${BASH_REMATCH[1]}"
      break
    fi
  done < <(echo -e "$body")
}

section_set() {
  local key="$1"
  local value="$2"
  local body="${3:-$CONFIG_SECTION}"

  local found=false
  local output=""
  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ ^$key\s*=\s*.+$ ]]; then
      found=true
      output="$output$key=$value\n"
    elif [[ -n "$line" ]]; then
      output="$output$line\n"
    fi
  done < <(echo -e "$body")

  if [[ $found == false ]]; then
    output="$output$key=$value\n"
  fi

  CONFIG_SECTION="$output\n"

}


section_del() {
  local key="$1"
  local body="${2:-$CONFIG_SECTION}"

  local output=""
  while IFS= read -r line || [ -n "$line" ]; do
    if ! [[ $line =~ ^$key\s*=\s*.+$ ]] && [[ -n "$line" ]]; then
      output="$output$line\n"
    fi
  done < <(echo -e "$body")

  CONFIG_SECTION="$output\n"
}

section_keys() {
  local body="${1:-$CONFIG_SECTION}"
  local keys=()
  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ ^(.*)\s*= ]]; then
      keys+=("${BASH_REMATCH[1]}")
    fi
  done < <(echo -e "$body")
  echo -e "${keys[@]}"
}

section_has() {
  [[ " $(config_keys "$2") " =~ " $1 " ]]
}

# src/lib/fs.sh
#!/bin/bash

fs_expanduser() {
  echo "${1/~/$HOME}"
}

fs_reluser() {
  echo "${1/$HOME/~}"
}

fs_dotfile() {
  local rel="$(fs_reluser "$1")"
  local pkg="$2"
  local fname="$(basename "$rel")"
  rel="${rel#~/}"
  fname="${fname#.}"

  local res=""
  if [ -n "$pkg" ]; then
    res="$DOTFILES$(dirname "$rel")/$pkg.$fname"
  else
    res="$DOTFILES$(dirname "$rel")/$fname"
  fi
  echo "${res/\/.\//\/}"
}

# src/lib/ui.sh
#!/bin/bash

_log() {
  local key="$1"
  shift
  printf "[%b] %b\n" "$key" "$*" >&2
}

linfo() {
  _log "$(greenBold "I")" "$@"
}

lwarn() {
  _log "$(yellowBold "W")" "$@"
}

lerror() {
  _log "$(redBold "E")" "$@"
}

confirm() {
  local prompt="$(cyanBold ">>>") $1"
  if [[ -t 1 ]]; then
    while true; do
      read -u 1 -n 1 -rp "$prompt (y/n): "
      printf '\n'
      case "$REPLY" in

        [Yy]*) return 0;;
        [Nn]*) return 1;;
        *) lwarn "Confirmation response must be 'y' or 'n'"
      esac
    done
  else
    return 1
  fi
}

PASSWORD=""
password() {
  local prompt="$(cyanBold ">>>") $1"
  if [[ -n "$PASSWORD" ]] ; then
    return 0
  fi

  if [[ -t 1 ]]; then
    while true; do
      read -srp "$prompt: " PASSWORD
      printf "\n"
      if [[ -z "$PASSWORD" ]]; then
        lwarn "Password must not be empty"
      else
        break
      fi
    done
  else
    return 1
  fi
}
get_password() {
  echo "$PASSWORD"
}

# src/lib/validations/validate_dir_exists.sh
validate_dir_exists() {
  [[ -d "$1" ]] || echo "must be an existing directory"
}

# src/lib/validations/validate_file_exists.sh
validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

# src/lib/validations/validate_file_or_dir_exists.sh
validate_file_or_dir_exists() {
  [[ -d "$1" ]] || [[ -f "$1" ]] || echo "must be an existing file or directory"
}

# src/lib/validations/validate_integer.sh
validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

# src/lib/validations/validate_not_empty.sh
validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

# :command.command_functions
# :command.function
dotm_add_command() {
  # src/add_command.sh
  #!/bin/bash
  inspect_args

  config_init "${DOTFILES}dotm.ini"

  for sysfile in ${args[FILE]}; do
    sysfile="${sysfile//\"/}"
    sysfile="$(fs_expanduser "$sysfile")"
    realfile="$sysfile"
    type="file"
    [ -e "$sysfile" ] || continue
    if [ -d "$sysfile" ]; then
      type="directory"
    fi

    if [[ -L "$sysfile" ]]; then
      realfile="$(realpath "$sysfile")"
    fi

    dotfile="$(fs_dotfile "$sysfile" "${args[--package]}")"
    if [[ "$realfile" = $DOTFILES/* ]]; then
      lwarn "The $type $(lscolor "$sysfile") is already tracked in the dotfiles"
      continue
    elif [[ -e "$dotfile" ]]; then
      if [[ -z "${args[--force]}" ]] && ! confirm "The dotfile $(lscolor "$dotfile") already exists, do you want to overwrite it"; then
        lwarn "The $type $(lscolor "$sysfile") would overwrite an existing dotfile, skipping"
        continue
      else
        lwarn "Overwriting $type $(lscolor "$dotfile") with $(lscolor "$sysfile")"
      fi
    fi
    linfo "Added $type $(lscolor "$sysfile") to the dotfiles"
  done
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --version | -v )
    version_command
    exit
    ;;

  --help | -h )
    long_usage=yes
    dotm_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  export DOTFILES="${DOTFILES:-$HOME/dotfiles.new/}"
  if [[ -z "${DOTFILES:-}" ]]; then
    printf "missing required environment variable: DOTFILES\n"
    exit 1
  fi
  # :command.dependencies_filter
  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  add | a )
    action="add"
    shift
    dotm_add_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  * )
    dotm_usage
    exit 1
    ;;

  esac
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dotm_add_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dotm_add_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  if ! [[ -x "$(command -v openssl)" ]]; then
    printf "missing dependency: openssl\n"
    exit 1
  fi
  if ! [[ -x "$(command -v tar)" ]]; then
    printf "missing dependency: tar\n"
    exit 1
  fi
  # :command.command_filter
  action="add"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --package | -p )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--package]="$2"
        shift
        shift
      else
        printf "%s\n" "--package requires an argument: --package, -p PACKAGE"
        exit 1
      fi
      ;;

    # :flag.case
    --encrypt | -e )
      # :flag.conflicts
      if [[ -n "${args[--copy]:-}" ]]; then
        printf "conflicting options: %s cannot be used with %s\n" "$key" "--copy"
        exit 1
      fi
      args[--encrypt]=1
      shift
      ;;

    # :flag.case
    --copy | -c )
      # :flag.conflicts
      for conflict in --encrypt --archive; do
        if [[ -n "${args[$conflict]:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "$conflict"
          exit 1
        fi
      done
      args[--copy]=1
      shift
      ;;

    # :flag.case
    --archive | -a )
      # :flag.conflicts
      if [[ -n "${args[--copy]:-}" ]]; then
        printf "conflicting options: %s cannot be used with %s\n" "$key" "--copy"
        exit 1
      fi
      args[--archive]=1
      shift
      ;;

    # :flag.case
    --force | -f )
      # :flag.conflicts
      args[--force]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[FILE]+x} ]]; then
        # :argument.validations
        if [[ -n $(validate_file_or_dir_exists "$1") ]]; then
          printf "validation error in %s:\n%s\n" "FILE" "$(validate_file_or_dir_exists "$1")"
          exit 1
        fi
        args[FILE]="\"$1\""
        shift
      else
        args[FILE]="${args[FILE]} \"$1\""
        shift
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[FILE]+x} ]]; then
    printf "missing required argument: FILE\nusage: dotm add FILE... [options]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  [[ -n ${args[--package]:-} ]] || args[--package]="host/$HOSTNAME"
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.initialize
initialize() {
  version="0.1.3"
  long_usage=''
  set -e

  # src/initialize.sh
  #!/bin/bash
}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  if [[ $action == "add" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dotm_add_usage
    else
      dotm_add_command
    fi

  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
